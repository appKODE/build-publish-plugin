package ru.kode.android.build.publish.plugin.telegram.task.changelog

import org.gradle.api.DefaultTask
import org.gradle.api.file.RegularFileProperty
import org.gradle.api.plugins.BasePlugin
import org.gradle.api.provider.Property
import org.gradle.api.provider.SetProperty
import org.gradle.api.tasks.Input
import org.gradle.api.tasks.InputFile
import org.gradle.api.tasks.Internal
import org.gradle.api.tasks.TaskAction
import org.gradle.api.tasks.options.Option
import org.gradle.workers.WorkQueue
import org.gradle.workers.WorkerExecutor
import ru.kode.android.build.publish.plugin.core.git.mapper.fromJson
import ru.kode.android.build.publish.plugin.telegram.config.DestinationBot
import ru.kode.android.build.publish.plugin.telegram.service.network.TelegramNetworkService
import ru.kode.android.build.publish.plugin.telegram.task.changelog.work.SendTelegramChangelogWork
import javax.inject.Inject

private const val MESSAGE_MAX_LENGTH = 4096

private const val ESCAPED_CHARACTERS =
    "[_]|[*]|[\\[]|[\\]]|[(]|[)]|[~]|[`]|[>]|[#]|[+]|[=]|[|]|[{]|[}]|[.]|[!]|-"

/**
 * A Gradle task that sends changelog notifications to Telegram.
 *
 * This task is responsible for processing and sending changelog notifications to configured
 * Telegram chats. It handles various aspects of message preparation and delivery:
 *
 * ## Features
 * - Reads changelog content from a file
 * - Formats issue references as clickable links using the configured issue tracker URL
 * - Escapes special characters for Telegram's MarkdownV2 format
 * - Splits long messages to fit Telegram's 4096 character limit
 * - Includes user mentions at the beginning of the message
 * - Sends notifications asynchronously using Gradle's worker API
 * - Supports multiple destination chats and bots
 *
 * @see TelegramNetworkService For the underlying network communication
 * @see SendTelegramChangelogWork For the actual work implementation
 */
abstract class SendTelegramChangelogTask
    @Inject
    constructor(
        private val workerExecutor: WorkerExecutor,
    ) : DefaultTask() {
        init {
            description = "Task to send changelog for Telegram"
            group = BasePlugin.BUILD_GROUP
        }

        /**
         * The network service property provides access to the Telegram network service used for sending
         * changelog notifications.
         *
         * This property is internal and should not be directly accessed by other plugins. Rather, it is
         * injected by Gradle when the task is created and configured.
         *
         * @see TelegramNetworkService For the actual network service implementation
         */
        @get:Internal
        abstract val networkService: Property<TelegramNetworkService>

        /**
         * The changelog file property contains the path to the file containing the changelog text to be sent.
         *
         * This file should contain the raw changelog text that will be formatted and sent to Telegram.
         * The file is expected to be in plain text format.
         */
        @get:InputFile
        @get:Option(
            option = "changelogFile",
            description = "File with saved changelog",
        )
        abstract val changelogFile: RegularFileProperty

        /**
         * The build tag file property contains a JSON file with information about the current build tag.
         *
         * This file is generated by the build process and contains metadata about the current build,
         * including version information and build number.
         */
        @get:InputFile
        @get:Option(
            option = "buildTagFile",
            description = "Json contains info about tag build",
        )
        abstract val buildTagFile: RegularFileProperty

        /**
         * The base output file name property specifies the base name used for the build output.
         *
         * This is typically the application ID or name that will be included in the Telegram message
         * to identify which application the changelog belongs to.
         */
        @get:Input
        @get:Option(
            option = "baseOutputFileName",
            description = "Application bundle name for changelog",
        )
        abstract val baseOutputFileName: Property<String>

        /**
         * The issue URL prefix property defines the base URL for issue tracker links.
         *
         * This URL is used to convert issue references (e.g., #123) in the changelog into clickable
         * links in the Telegram message.
         */
        @get:Input
        @get:Option(
            option = "issueUrlPrefix",
            description = "Address of task tracker",
        )
        abstract val issueUrlPrefix: Property<String>

        /**
         * The issue number pattern property defines the regular expression pattern used to identify
         * issue references in the changelog text.
         *
         * This pattern is used to detect and convert issue numbers into clickable links using the
         * configured issue URL prefix.
         */
        @get:Input
        @get:Option(
            option = "issueNumberPattern",
            description = "How task number formatted",
        )
        abstract val issueNumberPattern: Property<String>

        /**
         * The user mentions property contains a set of usernames or groups to be mentioned in the
         * Telegram message.
         *
         * These mentions will be included at the beginning of the message to notify specific users
         * or groups about the changelog update.
         */
        @get:Input
        @get:Option(
            option = "userMentions",
            description = "User tags to mention in chat",
        )
        abstract val userMentions: SetProperty<String>

        /**
         * The destination bots property defines which Telegram bots and chats should receive the changelog.
         *
         * This set contains [DestinationBot] objects, each specifying a bot configuration and the
         * list of chat names where the message should be sent.
         */
        @get:Input
        @get:Option(
            option = "destinationBots",
            description = "Bots which be used to post changelog",
        )
        abstract val destinationBots: SetProperty<DestinationBot>

        /**
         * Executes the changelog sending process.
         *
         * This is the main entry point for the task, called by Gradle when the task is executed.
         * It coordinates the entire process of reading, formatting, and sending the changelog.
         *
         * ## Process Flow
         * 1. Reads build tag information (version, build number) from the build tag file
         * 2. Validates that the changelog file exists and has content
         * 3. Formats issue references as clickable links using the configured pattern
         * 4. Escapes special characters for Telegram's MarkdownV2 format
         * 5. Splits the message into chunks if it exceeds Telegram's length limit
         * 6. Submits each chunk to a background worker for sending
         *
         * ## Error Handling
         * - Logs an error if the changelog file is empty or missing
         * - Handles network errors through the underlying network service
         *
         * @throws IllegalStateException If required configuration is missing
         * @throws IOException If there's an error reading the changelog file
         */
        @TaskAction
        fun sendChangelog() {
            val currentBuildTag = fromJson(buildTagFile.asFile.get())

            val changelog = changelogFile.orNull?.asFile?.readText()
            if (changelog.isNullOrEmpty()) {
                logger.error(
                    "[sendChangelog] changelog file not found, is empty or error occurred",
                )
            } else {
                val changelogWithIssues = changelog.formatIssues(ESCAPED_CHARACTERS)
                val userMentions =
                    userMentions.orNull.orEmpty()
                        .joinToString(", ")
                        .escapeCharacters(ESCAPED_CHARACTERS)

                val workQueue: WorkQueue = workerExecutor.noIsolation()
                if (changelogWithIssues.length > MESSAGE_MAX_LENGTH) {
                    changelogWithIssues
                        .chunked(MESSAGE_MAX_LENGTH)
                        .forEach { chunk ->
                            sendChangelogInternal(
                                workQueue = workQueue,
                                userMentions = userMentions,
                                changelog = chunk.formatIssues(ESCAPED_CHARACTERS),
                                currentBuildTagName = currentBuildTag.name,
                            )
                        }
                } else {
                    sendChangelogInternal(
                        workQueue = workQueue,
                        userMentions = userMentions,
                        changelog = changelogWithIssues,
                        currentBuildTagName = currentBuildTag.name,
                    )
                }
            }
        }

        /**
         * Sends a single chunk of the changelog to Telegram.
         *
         * This method creates and submits a work item to the provided work queue for
         * asynchronous processing. The actual sending happens in a background thread.
         *
         * @param workQueue The Gradle work queue to submit the task to
         * @param userMentions Formatted string of user mentions (e.g., "@user1 @user2")
         * @param changelog The changelog text to send (already formatted and escaped)
         * @param currentBuildTagName Name of the current build tag (for logging and context)
         *
         * @see SendTelegramChangelogWork For the actual work implementation
         */
        private fun sendChangelogInternal(
            workQueue: WorkQueue,
            userMentions: String,
            changelog: String,
            currentBuildTagName: String,
        ) {
            workQueue.submit(SendTelegramChangelogWork::class.java) { parameters ->
                parameters.baseOutputFileName.set(baseOutputFileName)
                parameters.buildName.set(currentBuildTagName)
                parameters.changelog.set(changelog)
                parameters.userMentions.set(userMentions)
                parameters.escapedCharacters.set(ESCAPED_CHARACTERS)
                parameters.networkService.set(networkService)
                parameters.destinationBots.set(destinationBots)
            }
        }

        /**
         * Formats issue references in the changelog text and escapes special characters.
         *
         * This method performs two main transformations:
         * 1. Converts issue references (e.g., #123) to clickable links using the configured URL pattern
         * 2. Escapes special characters that have special meaning in Telegram's MarkdownV2 format
         *
         * Example:
         * - Input: "Fixed issue #123"
         * - Output: "Fixed issue [#123](https://issuetracker.example.com/issue/123)"
         *
         * @param escapedCharacters Regex pattern of characters that need to be escaped
         * @return The formatted and escaped changelog text, ready to be sent to Telegram
         *
         * @see <a href="https://core.telegram.org/bots/api#markdownv2-style">Telegram MarkdownV2 Format</a>
         */
        private fun String.formatIssues(escapedCharacters: String): String {
            val issueUrlPrefix = issueUrlPrefix.get()
            val issueNumberPattern = issueNumberPattern.get()
            val issueRegexp = issueNumberPattern.toRegex()

            val matchResults = issueRegexp.findAll(this).distinctBy { it.value }
            var out = this.escapeCharacters(escapedCharacters)

            matchResults.forEach { matchResult ->
                val formattedResult = matchResult.value.escapeCharacters(escapedCharacters)
                val url = (issueUrlPrefix + matchResult.value).escapeCharacters(escapedCharacters)
                val issueId = matchResult.value.escapeCharacters(escapedCharacters)
                val link = "[$issueId]($url)"
                out = out.replace(formattedResult, link)
            }
            return out
        }

        /**
         * Splits a string into chunks of specified length, respecting word boundaries.
         *
         * This method ensures that the message is split in a way that maintains readability:
         * 1. First tries to split on the specified delimiter (default: newline)
         * 2. If a single line is still too long, falls back to splitting on spaces
         * 3. If a single word is too long, it will be split at the exact character limit
         *
         * @param chunkLength Maximum length of each chunk (in UTF-16 code units)
         * @param delimiter Character to prefer for splitting (defaults to newline)
         * @return List of string chunks, each within the specified length limit
         *
         * @throws IllegalArgumentException If chunkLength is less than or equal to 0
         */
        private fun String.chunked(
            chunkLength: Int,
            delimiter: Char = '\n',
        ): List<String> {
            val result = mutableListOf<String>()
            var currentIndex = 0
            while (currentIndex < this.length) {
                var nextNewlineIndex = currentIndex
                var tempNewlineIndex = currentIndex
                while (tempNewlineIndex < (currentIndex + chunkLength)) {
                    tempNewlineIndex = this.indexOf(delimiter, tempNewlineIndex + 1)
                    if (tempNewlineIndex == -1) {
                        val chunk = this.substring(currentIndex, nextNewlineIndex)
                        result.add(chunk)
                        return result
                    }
                    if (tempNewlineIndex <= (currentIndex + chunkLength)) {
                        nextNewlineIndex = tempNewlineIndex
                    }
                }
                val chunk = this.substring(currentIndex, nextNewlineIndex)
                result.add(chunk)
                currentIndex = nextNewlineIndex
            }
            return result
        }
    }

private fun String.escapeCharacters(escapedCharacters: String): String {
    return this.replace(escapedCharacters.toRegex()) { result -> "\\${result.value}" }
}
